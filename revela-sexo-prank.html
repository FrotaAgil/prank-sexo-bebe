<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
<title>Descobrir o sexo do beb√™ üéâ</title>
<meta name="theme-color" content="#ff69b4">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="mobile-web-app-capable" content="yes">
<style>
  :root{
    --bg:#f0f8ff;
    --card:#ffffff;
    --muted:#6b7280;
    --text:#374151;
    --primary:#3b82f6;
    --secondary:#8b5cf6;
    --accent:#10b981;
    --warm:#f59e0b;
    --coral:#ff6b6b;
    --teal:#14b8a6;
    --indigo:#6366f1;
    --emerald:#059669;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;overflow:hidden}
  body{
    font-family: "Comic Sans MS", cursive, system-ui, -apple-system, "Segoe UI", Roboto;
    background: 
      radial-gradient(circle at 20% 20%, var(--primary) 0%, transparent 50%),
      radial-gradient(circle at 80% 20%, var(--secondary) 0%, transparent 50%),
      radial-gradient(circle at 40% 70%, var(--warm) 0%, transparent 50%),
      radial-gradient(circle at 80% 80%, var(--indigo) 0%, transparent 50%),
      radial-gradient(circle at 10% 80%, var(--accent) 0%, transparent 50%),
      linear-gradient(135deg, #f8fafc 0%, #e0f2fe 25%, #fef3e2 50%, #f3e8ff 75%, #ecfdf5 100%);
    color:var(--text);
    display:flex;align-items:center;justify-content:center;
    padding:10px;
    -webkit-user-select:none; user-select:none;
    -webkit-touch-callout: none;
    -webkit-tap-highlight-color: transparent;
    position:fixed;inset:0;
    animation: backgroundShift 10s ease-in-out infinite;
  }
  
  @keyframes backgroundShift {
    0%, 100% { filter: hue-rotate(0deg) brightness(1); }
    25% { filter: hue-rotate(15deg) brightness(1.1); }
    50% { filter: hue-rotate(30deg) brightness(1.05); }
    75% { filter: hue-rotate(15deg) brightness(1.1); }
  }
  
  /* Elementos decorativos flutuantes */
  body::before {
    content: 'üåà ‚≠ê üéà ü¶Ñ üå∏ üéÄ üß∏ üë∂ üíï üéâ üéä üåü üéÅ üçº üå∫ ü¶ã';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    font-size: 24px;
    opacity: 0.1;
    pointer-events: none;
    z-index: 1;
    animation: floatElements 20s linear infinite;
    white-space: pre;
    line-height: 3;
    letter-spacing: 2em;
  }
  
  @keyframes floatElements {
    0% { transform: translateY(100vh) rotate(0deg); }
    100% { transform: translateY(-100vh) rotate(360deg); }
  }
  
  .arena{
    position:relative; 
    width: 100%;
    height: 100vh;
    height: 100dvh; /* Dynamic viewport height para mobile */
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    touch-action: none;
    z-index: 2;
    /* Otimiza√ß√µes para touchscreen */
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
  }
  
  .cta{
    position: relative;
    display: inline-block; 
    padding: clamp(24px, 6vw, 32px) clamp(40px, 10vw, 48px); 
    font-weight: 800; 
    font-size: clamp(22px, 7vw, 32px);
    color: #fff; 
    border: 0; 
    border-radius: 30px;
    background: linear-gradient(45deg, var(--primary), var(--secondary), var(--indigo));
    background-size: 200% 200%;
    box-shadow: 0 16px 40px rgba(59,130,246,.6), 0 12px 30px rgba(139,92,246,.5);
    cursor: pointer; 
    touch-action: manipulation; /* Otimizado para touch */
    -webkit-tap-highlight-color: transparent;
    transition: all .15s ease;
    min-width: clamp(280px, 60vw, 320px);
    min-height: 80px; /* √Årea de toque ainda maior */
    white-space: nowrap;
    animation: gradientShift 3s ease-in-out infinite;
    font-family: "Comic Sans MS", cursive;
    text-shadow: 2px 2px 4px rgba(0,0,0,.3);
    text-align: center;
    /* Melhor performance em mobile */
    will-change: transform;
    -webkit-backface-visibility: hidden;
    backface-visibility: hidden;
    /* √Årea de toque expandida ainda mais */
    position: relative;
  }
  
  /* Pseudo-elemento para expandir √°rea de toque significativamente */
  .cta::before {
    content: '';
    position: absolute;
    top: -20px;
    left: -20px;
    right: -20px;
    bottom: -20px;
    z-index: -1;
    border-radius: 50px;
  }
  
  /* √Årea de detec√ß√£o de proximidade visual (invis√≠vel) */
  .cta::after {
    content: '';
    position: absolute;
    top: -40px;
    left: -40px;
    right: -40px;
    bottom: -40px;
    z-index: -2;
    border-radius: 70px;
    /* Debug: descomente para ver a √°rea de detec√ß√£o */
    /* border: 2px dashed rgba(255,0,0,0.3); */
  }
  
  @keyframes gradientShift {
    0%, 100% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
  }
  
  .cta:hover{
    transform: scale(1.05);
  }
  
  .cta:active{ 
    transform: scale(.95);
  }
  
  /* Anima√ß√µes quando o bot√£o come√ßa a se mover */
  .cta.moving{
    position: absolute !important;
    animation: shake 0.5s ease-in-out, gradientShift 3s ease-in-out infinite;
    /* Feedback visual melhorado para mobile */
    transform-origin: center;
    transition: transform 0.1s ease-out;
  }
  
  .cta.rainbow{
    background: linear-gradient(90deg,var(--primary),var(--secondary),var(--accent),var(--warm),var(--indigo),var(--coral),var(--primary));
    background-size: 400% 100%;
    animation: rainbow 1.5s linear infinite, bounce 0.5s ease-in-out, pulse 0.3s ease-in-out;
  }
  
  /* Nova anima√ß√£o de pulse para feedback t√°til */
  @keyframes pulse {
    0% { transform: scale(1); box-shadow: 0 16px 40px rgba(59,130,246,.6), 0 12px 30px rgba(139,92,246,.5); }
    50% { transform: scale(1.08); box-shadow: 0 20px 50px rgba(59,130,246,.8), 0 16px 40px rgba(139,92,246,.7); }
    100% { transform: scale(1); box-shadow: 0 16px 40px rgba(59,130,246,.6), 0 12px 30px rgba(139,92,246,.5); }
  }
  
  @keyframes shake {
    0%, 100% { transform: rotate(0deg) scale(1); }
    25% { transform: rotate(-8deg) scale(1.05); }
    50% { transform: rotate(0deg) scale(1.1); }
    75% { transform: rotate(8deg) scale(1.05); }
  }
  
  @keyframes rainbow {
    0% { background-position: 0% 50%; }
    100% { background-position: 100% 50%; }
  }
  
  @keyframes bounce {
    0%, 100% { transform: scale(1); }
    25% { transform: scale(1.15) rotate(-3deg); }
    50% { transform: scale(1.2) rotate(0deg); }
    75% { transform: scale(1.15) rotate(3deg); }
  }
  
  /* Feedback visual para proximidade em mobile */
  .cta.proximity-detected {
    animation: proximityPulse 0.6s ease-in-out infinite;
    box-shadow: 0 20px 50px rgba(59,130,246,.8), 0 16px 40px rgba(139,92,246,.7), 0 0 30px rgba(255,255,255,.5);
  }
  
  @keyframes proximityPulse {
    0%, 100% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.03); opacity: 0.95; }
  }
  
  /* Anima√ß√£o de escape mais dram√°tica */
  .cta.escaping {
    animation: escape 0.4s ease-out;
  }
  
  @keyframes escape {
    0% { transform: scale(1) rotate(0deg); }
    30% { transform: scale(0.9) rotate(-15deg); }
    60% { transform: scale(1.1) rotate(10deg); }
    100% { transform: scale(1) rotate(0deg); }
  }
  
  @keyframes rainbow {
    0% { background-position: 0% 50%; }
    100% { background-position: 100% 50%; }
  }
  
  @keyframes bounce {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.15); }
  }
  
  .emoji-rain{
    position: absolute;
    font-size: 28px;
    pointer-events: none;
    animation: fall 3s linear forwards;
    z-index: 10;
  }
  
  @keyframes fall {
    0% { transform: translateY(-50px) rotate(0deg); opacity: 1; }
    100% { transform: translateY(400px) rotate(360deg); opacity: 0; }
  }
  
  .fake-reveal{
    position: fixed;
    inset: 0;
    background: rgba(255,255,255,0.95);
    backdrop-filter: blur(5px);
    display: none;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    z-index: 20;
  }
  
  .fake-reveal.show{
    display: flex;
    animation: fadeIn 0.5s ease;
  }
  
  @keyframes fadeIn {
    from { opacity: 0; transform: scale(0.8); }
    to { opacity: 1; transform: scale(1); }
  }
  
  .fake-reveal h2{
    font-size: clamp(28px, 8vw, 40px);
    margin: 0 0 20px;
    color: var(--primary);
    font-family: "Comic Sans MS", cursive;
    text-shadow: 2px 2px 4px rgba(59,130,246,.3);
    text-align: center;
  }
  
  .fake-reveal .close-btn{
    padding: 15px 30px;
    background: linear-gradient(45deg, var(--primary), var(--secondary));
    color: white;
    border: none;
    border-radius: 15px;
    font-size: 18px;
    font-weight: bold;
    cursor: pointer;
    margin-top: 20px;
    font-family: "Comic Sans MS", cursive;
    box-shadow: 0 4px 15px rgba(59,130,246,.3);
    transition: transform 0.2s ease;
  }
  
  .fake-reveal .close-btn:hover{
    transform: scale(1.05);
  }
  
  /* Melhorias para mobile touchscreen */
  @media (max-width: 480px) {
    body { 
      padding: 8px;
      /* Previne bounce no iOS */
      -webkit-overflow-scrolling: touch;
      overscroll-behavior: none;
    }
    
    .cta { 
      min-width: clamp(200px, 60vw, 260px);
      min-height: 70px; /* √Årea de toque ainda maior no mobile */
      padding: clamp(22px, 6vw, 26px) clamp(36px, 10vw, 44px);
      font-size: clamp(22px, 7vw, 30px);
      border-radius: 30px;
      box-shadow: 0 15px 40px rgba(255,105,180,.6), 0 10px 30px rgba(135,206,235,.5);
    }
    
    /* √Årea de toque expandida ainda mais no mobile */
    .cta::before {
      top: -15px;
      left: -15px;
      right: -15px;
      bottom: -15px;
    }
    
    .fake-reveal {
      margin: 15px;
      padding: 30px 20px;
    }
    
    .fake-reveal h2 {
      font-size: clamp(32px, 10vw, 44px);
    }
    
    .fake-reveal .close-btn {
      padding: 18px 36px;
      font-size: 20px;
      min-height: 56px; /* √Årea de toque adequada */
    }
  }
  
  /* Landscape mobile - otimizado para touchscreen */
  @media (max-height: 500px) and (orientation: landscape) {
    .arena {
      height: 100vh;
      height: 100dvh;
    }
    
    .cta {
      min-height: 55px;
      padding: clamp(18px, 4vw, 22px) clamp(30px, 7vw, 38px);
    }
  }
  
  /* Dispositivos com notch (iPhone X+) */
  @media (max-width: 480px) {
    body {
      padding: max(8px, env(safe-area-inset-top)) max(8px, env(safe-area-inset-right)) max(8px, env(safe-area-inset-bottom)) max(8px, env(safe-area-inset-left));
    }
  }
</style>
</head>
<body>
  <div id="arena" class="arena">
    <button id="cta" class="cta" type="button">Descobrir agora</button>
    
    <div id="fake-reveal" class="fake-reveal">
      <h2 id="reveal-text">üéâ √â uma menina! üë∂üíï</h2>
      <p>Parab√©ns! Que alegria!</p>
      <button class="close-btn" onclick="closeFakeReveal()">Fechar</button>
    </div>
  </div>

<script>
(function(){
  const arena = document.getElementById('arena');
  const btn = document.getElementById('cta');
  const fakeReveal = document.getElementById('fake-reveal');
  const revealText = document.getElementById('reveal-text');
  
  let isMoving = false;
  let attempts = 0;

  const emojiRain = ['üéâ', 'üéä', 'üë∂', 'üíï', 'üíô', 'üíñ', 'üçº', 'üß∏', 'üëë', '‚≠ê', 'üåà', 'ü¶Ñ', 'üéà', 'üå∏', 'üéÄ'];
  
  const fakeReveals = [
    { text: "üéâ √â uma menina! üë∂üíï", subtitle: "Parab√©ns! Que alegria!" },
    { text: "üéä √â um menino! üë∂üíô", subtitle: "Que felicidade!" },
    { text: "üò± S√£o g√™meos! üë∂üë∂", subtitle: "Dupla surpresa!" },
    { text: "ü¶Ñ √â um unic√≥rnio! üåà", subtitle: "Isso √© raro!" },
    { text: "ü§ñ √â um rob√¥! üîß", subtitle: "Do futuro!" },
    { text: "üê∂ √â um cachorrinho! üêï", subtitle: "Au au!" },
    { text: "üåà √â um arco-√≠ris! ‚ú®", subtitle: "Que m√°gico!" },
    { text: "üß∏ √â um ursinho! üêª", subtitle: "Que fofo!" }
  ];

  // Impede context menu / sele√ß√£o / zoom
  window.addEventListener('contextmenu', e => e.preventDefault());
  let lastTouchEnd = 0;
  window.addEventListener('touchend', function(e){
    const now = Date.now();
    if(now - lastTouchEnd <= 300){ e.preventDefault(); }
    lastTouchEnd = now;
  }, {passive:false});

  // Vibra√ß√£o se dispon√≠vel
  function vibrate(pattern = [50]) {
    if (navigator.vibrate) {
      navigator.vibrate(pattern);
    }
  }

  // Chuva de emojis
  function createEmojiRain() {
    for(let i = 0; i < 12; i++) {
      setTimeout(() => {
        const emoji = document.createElement('div');
        emoji.className = 'emoji-rain';
        emoji.textContent = emojiRain[Math.floor(Math.random() * emojiRain.length)];
        emoji.style.left = Math.random() * 100 + '%';
        emoji.style.animationDelay = Math.random() * 0.5 + 's';
        arena.appendChild(emoji);
        
        setTimeout(() => emoji.remove(), 3000);
      }, i * 80);
    }
  }

  // Revela√ß√£o falsa ocasional
  function showFakeReveal() {
    const reveal = fakeReveals[Math.floor(Math.random() * fakeReveals.length)];
    revealText.textContent = reveal.text;
    fakeReveal.querySelector('p').textContent = reveal.subtitle;
    fakeReveal.classList.add('show');
    
    vibrate([100, 50, 100, 50, 100]);
    createEmojiRain();
    
    // Fecha automaticamente ap√≥s 4 segundos
    setTimeout(() => {
      if (fakeReveal.classList.contains('show')) {
        closeFakeReveal();
      }
    }, 4000);
  }

  window.closeFakeReveal = function() {
    fakeReveal.classList.remove('show');
  }

  // Fun√ß√£o para iniciar o movimento do bot√£o
  function startMoving() {
    if (isMoving) return;
    
    isMoving = true;
    btn.classList.add('moving');
    
    // Posiciona o bot√£o na posi√ß√£o atual antes de come√ßar a se mover
    const rect = btn.getBoundingClientRect();
    const arenaRect = arena.getBoundingClientRect();
    btn.style.left = (rect.left - arenaRect.left + rect.width/2) + 'px';
    btn.style.top = (rect.top - arenaRect.top + rect.height/2) + 'px';
    btn.style.transform = 'translate(-50%, -50%)';
  }

  // Calcula posi√ß√£o segura para o bot√£o se mover
  function randomPosition(avoidRect){
    const pad = 20;
    const a = arena.getBoundingClientRect();
    const bw = btn.offsetWidth;
    const bh = btn.offsetHeight;
    const minX = pad + bw/2;
    const maxX = a.width - pad - bw/2;
    const minY = pad + bh/2;
    const maxY = a.height - pad - bh/2;

    function gen(){
      const x = Math.random() * (maxX - minX) + minX;
      const y = Math.random() * (maxY - minY) + minY;
      return {x,y};
    }
    
    let tries = 0;
    while(tries < 50){
      const p = gen();
      if(!avoidRect){
        return p;
      }
      const dx = Math.max(avoidRect.left - p.x, 0, p.x - avoidRect.right);
      const dy = Math.max(avoidRect.top - p.y, 0, p.y - avoidRect.bottom);
      const dist = Math.sqrt(dx*dx + dy*dy);
      if(dist > 110){
        return p;
      }
      tries++;
    }
    return gen();
  }

  function placeAt(x,y){
    btn.style.left = x+'px';
    btn.style.top = y+'px';
    btn.style.transform = 'translate(-50%,-50%) rotate(' + (Math.random()*10-5) + 'deg)';
  }

  function evade(near){
    if (!isMoving) return;
    
    // Vibra√ß√£o de feedback mais intensa para mobile
    const vibrationPattern = window.innerWidth < 768 ? [50, 30, 50] : [40];
    vibrate(vibrationPattern);
    
    // Adiciona classe de escape para anima√ß√£o visual
    btn.classList.add('escaping');
    setTimeout(() => btn.classList.remove('escaping'), 400);
    
    // Anima√ß√µes aleat√≥rias
    btn.classList.remove('shake', 'rainbow', 'proximity-detected');
    const animations = ['shake', 'rainbow'];
    if (Math.random() > 0.6) {
      btn.classList.add(animations[Math.floor(Math.random() * animations.length)]);
      setTimeout(() => btn.classList.remove('shake', 'rainbow'), 800);
    }
    
    const p = randomPosition(near);
    placeAt(p.x, p.y);
    
    // Revela√ß√£o falsa ocasional (10% de chance ap√≥s 5 tentativas)
    if (attempts > 5 && Math.random() < 0.1) {
      setTimeout(showFakeReveal, 600);
    }
  }

  // Fun√ß√£o para detectar proximidade e dar feedback visual
  function checkProximity(distance, isTouch = false) {
    const proximityThreshold = isTouch ? 220 : 180;
    
    if (distance < proximityThreshold && !isMoving) {
      btn.classList.add('proximity-detected');
      // Vibra√ß√£o sutil para indicar proximidade em mobile
      if (isTouch) {
        vibrate([20]);
      }
    } else if (distance > proximityThreshold) {
      btn.classList.remove('proximity-detected');
    }
  }

  // Eventos do mouse - inicia movimento quando mouse se aproxima
  arena.addEventListener('mousemove', (e)=>{
    const r = arena.getBoundingClientRect();
    const near = {left:e.clientX - r.left, top:e.clientY - r.top, right:e.clientX - r.left, bottom:e.clientY - r.top};
    const b = btn.getBoundingClientRect();
    const dx = e.clientX - (b.left + b.width/2);
    const dy = e.clientY - (b.top + b.height/2);
    const d = Math.hypot(dx,dy);
    
    // Dist√¢ncia de detec√ß√£o adaptativa baseada no tamanho da tela
    const detectionDistance = window.innerWidth < 768 ? 180 : 150;
    const evadeDistance = window.innerWidth < 768 ? 160 : 130;
    
    // Se n√£o est√° se movendo e o mouse se aproxima, inicia o movimento
    if (!isMoving && d < detectionDistance) {
      startMoving();
      attempts++;
    }
    
    // Se j√° est√° se movendo e o mouse est√° pr√≥ximo, foge
    if (isMoving && d < evadeDistance) {
      evade(near);
    }
  });

  // Eventos de touch - inicia movimento quando toque se aproxima
  let lastMove = 0;
  arena.addEventListener('touchmove', (e)=>{
    if (!e.touches || e.touches.length===0) return;
    
    const t = e.touches[0];
    const r = arena.getBoundingClientRect();
    const near = {left:t.clientX - r.left, top:t.clientY - r.top, right:t.clientX - r.left, bottom:t.clientY - r.top};
    const b = btn.getBoundingClientRect();
    const dx = t.clientX - (b.left + b.width/2);
    const dy = t.clientY - (b.top + b.height/2);
    const d = Math.hypot(dx,dy);
    
    // Dist√¢ncia de detec√ß√£o adaptativa para touch (maior em mobile)
    const detectionDistance = window.innerWidth < 768 ? 200 : 150;
    
    // Se n√£o est√° se movendo e o toque se aproxima, inicia o movimento
    if (!isMoving && d < detectionDistance) {
      startMoving();
      attempts++;
    }
    
    // Se j√° est√° se movendo, foge com throttle otimizado
    const now = Date.now();
    const throttleTime = window.innerWidth < 768 ? 15 : 20; // Mais responsivo em mobile
    if(isMoving && now - lastMove > throttleTime){
      evade(near);
      lastMove = now;
    }
    e.preventDefault();
  }, {passive:false});

  // Evento de hover no bot√£o - inicia movimento imediatamente
  btn.addEventListener('mouseenter', (e) => {
    if (!isMoving) {
      startMoving();
      attempts++;
      
      // Foge imediatamente quando o mouse entra no bot√£o
      const r = arena.getBoundingClientRect();
      const b = btn.getBoundingClientRect();
      const centerX = b.left + b.width/2 - r.left;
      const centerY = b.top + b.height/2 - r.top;
      evade({left: centerX, top: centerY, right: centerX, bottom: centerY});
    }
  });

  // Evento de clique/touch no bot√£o - agora s√≥ foge se j√° estiver se movendo
  function handleButtonClick(e) {
    if (!isMoving) {
      startMoving();
      attempts++;
    }
    
    // Se j√° est√° se movendo, faz o bot√£o fugir
    if (isMoving) {
      const t = e.touches && e.touches[0];
      if (t) {
        const r = arena.getBoundingClientRect();
        evade({left:t.clientX - r.left, top:t.clientY - r.top, right:t.clientX - r.left, bottom:t.clientY - r.top});
      } else if (e.clientX) {
        const r = arena.getBoundingClientRect();
        evade({left:e.clientX - r.left, top:e.clientY - r.top, right:e.clientX - r.left, bottom:e.clientY - r.top});
      } else {
        evade();
      }
    }
    
    e.preventDefault();
  }

  // Eventos de touch otimizados para mobile
  let touchStartTime = 0;
  let touchMoveCount = 0;
  
  btn.addEventListener('touchstart', function(e) {
    e.preventDefault();
    touchStartTime = Date.now();
    touchMoveCount = 0;
    
    const touch = e.touches[0];
    const rect = btn.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    const distance = Math.sqrt(
      Math.pow(touch.clientX - centerX, 2) + 
      Math.pow(touch.clientY - centerY, 2)
    );
    
    // Inicia movimento se o toque estiver pr√≥ximo (150px)
    if (distance <= 150) {
      if (!isMoving) {
        startMoving();
        attempts++;
        vibrate([30]);
      }
      
      // Se j√° est√° se movendo, evade imediatamente
      if (isMoving && distance <= 130) {
        evade();
      }
    }
  }, {passive: false});

  btn.addEventListener('touchmove', function(e) {
    e.preventDefault();
    touchMoveCount++;
    
    if (isMoving) {
      // Evade a cada movimento se estiver pr√≥ximo
      const touch = e.touches[0];
      const rect = btn.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      const distance = Math.sqrt(
        Math.pow(touch.clientX - centerX, 2) + 
        Math.pow(touch.clientY - centerY, 2)
      );
      
      if (distance <= 130) {
        // Evade com throttle para performance
        if (touchMoveCount % 3 === 0) {
          evade();
        }
      }
    }
  }, {passive: false});

  btn.addEventListener('touchend', function(e) {
    e.preventDefault();
    const touchDuration = Date.now() - touchStartTime;
    
    // Se foi um toque r√°pido (tap) e n√£o houve muito movimento
    if (touchDuration < 200 && touchMoveCount < 5) {
      handleButtonClick();
    }
  }, {passive: false});

  // Adiciona evento de click para desktop
  btn.addEventListener('click', handleButtonClick);

  // Redimensionamento
  window.addEventListener('resize', ()=>{
    if (isMoving) {
      setTimeout(() => {
        const p = randomPosition();
        placeAt(p.x, p.y);
      }, 100);
    }
  });

  // Orienta√ß√£o
  window.addEventListener('orientationchange', ()=>{
    if (isMoving) {
      setTimeout(() => {
        const p = randomPosition();
        placeAt(p.x, p.y);
      }, 300);
    }
  });
})();
</script>
</body>
</html>
